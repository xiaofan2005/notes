- 面向对象方法中的“类”——具有相同属性和行为的一组对象的集合
- 分类依据的原则——抽象
- 封装   把对象的属性和行为包装成一个，目的保护数据
- 继承

<u>**中文在C++中由于编码方式很多，可能输出中文时可能会乱码**</u>

# 杂

1. #include   被称为预处理指令
2. iostream 为输入输出流（`istream`/`ostream`）
3. **using namespace是针对命名空间的指令**
4. `cin`>>?>>?;  `cin`函数用于输入数值
   `cout`<<"?"<<"?" ; `cout`函数可把紧随的“”之中的内容输出
5. \n是一个字符：换行符——`endl `是一个换行符（同时还能清清除缓存）
6. 强制类型转换：` float() `/` int()` /` double()`  括号内为想要转换的变量名
   隐含转换
7. `size(表达式)` `  sizeof（类型名）`

# 自定义数据类型

### typedef语句——为一个已有的数据类型另外命名 <!--起别名（笑）-->

​			语法形式：typedef 已有数据类型  新类型名表
​				例如：

```cpp						
typedef double area , volume;
area a;
volume b; 
```

### enum语句——枚举类型

声明形式： `enum` 枚举类型名 {枚举元素}；   <!--枚举元素是一个个的常量,不可对其赋值-->
	例如：

```cpp
enum weekday{sun,mon,tue,wed,thu,fri,sat};  // 枚举元素有默认值，他们对应为 0、1、 2.....
weekday a; a=mon;  // 定义一个weekday类型的变量a并赋值mon
a = weekday {4}; <=> a = thu;
//枚举值可以进行关系运算
enum weekday{sun = 4,mon=1,tue,wed,thu,fri,sat}; //枚举值可在声明时另行指定值，但最好保证枚举元素值不同;指定后，元素对应值为前一个已知值顺序增
//整数值不可直接赋值给枚举变量，需强制转换
```

### 结构体

同C

# 函数

函数可以嵌套调用，但不可以嵌套定义

## 参数传递机制

### 传递形参

- 只有在函数被**调用**的时候，才会分配形参的存储单元
- 实参可以是变量、常量、表达式·
- 实参类型同形参类型
- 单向传递

### 用引用做形参

- 引用（&）是标识符的别名
- 声明一个引用时，必须同时对它进行初始化，使它指向一个已存在变量
- 一旦一个引用被初始化后，就不可以改变指向其他对象
- 引用可做形参   //   void swap(int &a, int&b) 

```cpp
int i,j;
int &ri = i;//建立一个int型的引用ri，并将其初始化为变量i的一个别名
j = 10;
ri = j;//相当于i = j;
```

引用不是变量，并不会给分配存储

## 内联函数

- 声明时使用  关键字inline
- 内联函数体内不能有循环语句和switch
- 其定义在第一次调用之前

## 带默认形参值的函数

- 在**定义**时预先给出默认的形参值，调用时若给出实参，用实参值，否则用默认形参值.<!--不会在声明处给出默认值-->

- 在声明的默认形参值**右面**不能有普通的不带默认形参的参数

  ```cpp
  int add (int x=10,int y=5);
  int add (int c, int x=10,int y=5);
  int add (int x=10,int y=5,int c); //wrong
  int add (int x=10,int c,int y=5); //wrong
  ```

  ## 函数重载

  功能相近的函数在相同的作用域内以相同的函数名声明

  重载函数的形参必须不同：个数或类型不同		

  程序将依据实参和形参的类型及个数的最佳匹配来选择调用

  不可将不同功能的函数定义为重载

## C++系统函数

使用系统函数必须包含头问价

# 类与对象

封装：将抽象出的数据成员、代码成员相结合成一个整体
实现封装：类声明中的{}

继承与派生

多态性

## 类

类是用户的一种自定义类型，声明形式：

```cpp
class clock//类名
{
    //函数或数据成员
    public:
    	void settime();
    	void showtime();
    private:
    	int hour,minute,second;
};
```

```cpp
class 类名称
{
	public: //公有类型成员（外部接口）
	private:// 私有成员;只允许类中的函数访问
    protected://保护型成员
};
```



- 所有的属性（类内变量）应当是 `private`，为了读取它们的值，你应当使用相应的 `GetXXX()` 方法（类内函数）。这通常叫做“封装”。
- 如果一个方法需要在外部被使用，则它应该是 `public` 的。一个类必须要有 `public` 的方法，否则这个类的存在毫无意义，因为它是一个完全封闭的个体。

### 成员函数

- 可以直接在类中给出成员函数的函数体
- 也可以先在类中给出说明原型，类外给出函数体实现(写出函数名，例：`void clock::settime`在前面加上所述的**类的名字**)
- 在成员函数中可直接调用成员数据也可以调用其他成员函数
- 允许声明重载函数、带默认形参值的函数

#### 内联成员函数

- 对于较简单的成员函数可声明为内联函数
- 不可有较复杂结构（循环、switch等）

### 类中成员访问方式

- 类内互访
- 类外访问：使用`对象名.成员名`  <!--是对象名--> //成员名可数据可函数

## 对象

类的对象就是类类型的变量

声明形式：`类名  对象名;` 

## 构造函数与析构函数

### 构造函数

- 其将对象初始化为一个特定的状态;在对象创建时由系统自动调用
- **构造函数名为类名**,并且没有返回类型
- 无参数的构造函数为默认构造函数（若未声明，则自动产生默认形式的构造函数;在创建对象时，会自动调用默认的构造函数）
- 如果定义了带参数的构造函数，则编译器不会再提供默认的无参构造函数。

```cpp
class Clock 
{
	Clock(){}//不带参数的默认函数    
    Clock(){Hour = 12; Min = 3; Sec = 12;}    
    Clock(int NewH,int NewM,int NewS){Hour = NewH; Min = NewM; Sec = NewS;}//带参数的构造函数
    Clock(int NewH,int NewM,int NewS);//定义默认参数的构造函数。！！会有问题！！
};
```

```cpp
class Example {
public:
    // 构造函数
    Example()
    {
        x = 0;
        y = 0;
    }
    // 其他成员函数
private:
    int x, y;
};

```



- 在这个例子中，Example类定义了一个构造函数，该函数将x和y初始化为0。在创建Example对象时，该构造函数将自动被调用，从而确保对象的数据成员被正确初始化。
- 构造函数可以重载，也就是说，一个类可以有多个构造函数，只要它们在参数数量或类型上有所不同。
- ’初始式‘形式的构造函数
- 若类中已声明一个构造函数，则不会再自动生成一个默认构造函数

```cpp
Clock::Clock(int NewH,int NewM,int NewS):Hour(NewH),Min(NewM),Sec(NewS)//写需要初始化的数据成员，等价于赋值行为
```

#### 拷贝构造函数

C++中的拷贝构造函数是一种特殊类型的构造函数，用于从一个已有对象创建一个新的对象。当使用赋值操作符或将一个对象作为函数参数传递时，拷贝构造函数会被自动调用。它的语法形式如下：

```cpp
class Example {
public:
    // 拷贝构造函数
    Example(const Example& other)
    7{
        x = other.x;
        y = other.y;
    }
    // 其他成员函数
private:
    int x, y;
};
```

在这个例子中，Example类定义了一个拷贝构造函数，它将创建一个新对象，并将其初始化为另一个Example对象的值。拷贝构造函数的参数是一个常量引用，指向将要被拷贝的对象。在拷贝构造函数的函数体中，我们将另一个对象的x和y成员变量的值分别拷贝到新对象的x和y成员变量中。

需要注意的是，拷贝构造函数应该接受一个const引用参数，而不是一个值参数。这是因为如果使用值参数，将会递归地调用拷贝构造函数，从而导致无限循环。此外，拷贝构造函数应该将参数声明为const

##### 调用拷贝构造函数的不同情况

1. 当用一个对象去初始化同类型的另一个对象时，拷贝构造函数会被调用。例如：

   ```cpp
   MyClass obj1; // 创建一个MyClass对象
   MyClass obj2(obj1); // 用obj1初始化obj2，调用拷贝构造函数
   ```

2. 当将一个对象作为函数参数传递给函数时，拷贝构造函数会被调用。例如：

```cpp
void func(MyClass obj); // 函数定义
MyClass obj1; // 创建一个MyClass对象
func(obj1); // 将obj1作为参数传递给func函数，调用拷贝构造函数   
```

3.当函数返回一个对象时，拷贝构造函数会被调用。例如：

```cpp
MyClass func(); // 函数定义
MyClass obj1 = func(); // 调用func函数返回一个MyClass对象，调用拷贝构造函数
```

4.当创建一个对象数组时，拷贝构造函数会被调用。例如：

```cpp
MyClass obj1; // 创建一个MyClass对象
MyClass objArr[3] = { obj1, obj1, obj1 }; // 创建一个MyClass对象数组，调用拷贝构造函数
```



### 析构函数

除了构造函数，C++中还有另一种特殊类型的成员函数，称为析构函数。析构函数与构造函数相反，它们在对象被销毁时自动调用，用于清理对象所使用的资源。例如，如果一个对象分配了内存或打开了文件，那么在该对象被销毁时，析构函数可以释放内存或关闭文件。析构函数的语法与构造函数非常相似，只是在名称前加上了一个波浪号(~)



```cpp
class Example {
public:
    Example() {
        x = 0;
        y = 0;
    }
    ~Example() {
        // 在此清理资源
    }
private:
    int x, y;
};
```

## 类的组合

类中的成员数据包含另外一个类的对象

```cpp
class line
{
    private:
    point p1, p2;//两端点
    char color;
    public:
    line(point i, point j, char c);
    line(line &l);
    void draw(void);//画出线段
    float length(point p1, p2);
    
};
```

定义形式：

```cpp
class ClassA
{
private:
    ClassB classb;
};

class ClassB
{
};
//先定义A，再定义B
```

在上述示例中，类`ClassA`中定义了一个`ClassB`的实例变量`classb`，从而实现了`ClassA`和`ClassB`之间的关联。可以通过以下方式来访问`ClassB`的成员函数和成员变量：

```cpp
ClassA a;
a.classb.method();  // 调用ClassB的成员函数
a.classb.attribute; // 访问ClassB的成员变量

```

### 类的组合的构造函数

- 调用顺序是按照成员变量在类中的定义顺序进行的。注意：内嵌对象在构造函数的初始化列表中出现的顺序与内嵌对象构造函数的调用顺序无关
- 在组合中，先调用被组合类的构造函数，然后才调用包含该类的构造函数。
- 注意：若B没有默认构造函数，那么在A的构造函数中必须显式地调用B的构造函数来初始化b

必须在初始化列表中进行初始化的数据成员

1. 没有默认构造函数的内嵌对象：必须为该对象提供参数
2. 内嵌对象有默认构造函数
3. 引用类型的数据成员：必须在初始化时绑定引用的成员

### 拷贝构造函数

# 数据共享与保护

## 标识符的作用域与可见性

### 作用域

1. 函数原型的作用域：声明时形参的作用范围就是函数原型的作用域(仅在括号内)
2. 全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。全局变量的生命周期与程序生命周期相同。
3. 局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。局部变量的生命周期与函数调用次数有关。
4. 块作用域（一对大括号内的就是'块'）：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
5. 类作用域：
   若在类X中的成员m且成员函数中没有声明同名变量，则可以在这个函数内访问成员m(通过`X.m`或者`X::m`或者`ptr->m`访问成员m)
6. 命名空间作用域：在命名空间内部声明的变量具有命名空间作用域，它们只能在命名空间内部访问。命名空间作用域变量在命名空间被定义时被创建，在命名空间被销毁时被销毁。具有命名空间作用域的变量也称为全局变量
7. 文件作用域：在文件内部声明的变量具有文件作用域，它们可以被文件内的所有函数访问。文件作用域变量在文件被打开时被创建，在文件被关闭时被销毁

### 可见性

- 可见性是指在程序的某个地方是否是有效的，是否能够被引用被访问。
- 在大多数时候，变量作用域与可见性是一致。但是两者的主要区别就在于能否被直接引用。一个变量可以有不同的作用域，但是在不同的作用域中可能有不同的可见性，比如在C++的基类和派生类中，派生类并不能直接访问基类的私有成员，这时候私有成员在派生类中是不可见的。但是，派生类可以通过共有成员函数访问基类的私有成员，所以基类的私有成员的作用域同时包括了基类和其派生类。

#### 常见的三种可见性类型

- public表示这个类的成员变量和成员函数都可以被任何人访问
- public表示这个类的成员变量和成员函数都可以被任何人访问
- protected的开放程度要略高于private，但是略低于public，它表示这个类本身和它的子类，都可以访问和使用protected，但是除了这个类自己和它的子类，其他都不可以。

#### 作用域可见性的一般规则

1. 标识符要声明在前，引用在后
2. 同一作用域中，不能声明同名的标识符
3. 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响
4. 若在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见

## 对象的生存期

### 静态生存期

- 静态生存期：对象的生存期和程序的运行期相同。

- 具有静态生存期的对象包括
             在命名空间作用域中声明的对象和在局部作用域中使用关键字static声明的对象。
- **当函数（局部作用域）中的变量采用static修饰时，该变量不会在每次调用后被销毁，也就是下一次调用该函数时依旧保存上一次调用的状态，同时该变量也不会在每次调用都被初始化**
- 当函数（局部作用域）中的变量采用static修饰时，该变量不会在每次调用后被销毁，也就是下一次调用该函数时依旧保存上一次调用的状态，同时该变量也不会在每次调用都被初始化

```c++
#include <iostream.h>
void fun();
int main()
{
    fun();
    fun();
}
void fun()
{
    static int a = 1;//a是动态生存期
    int i = 5;
    a++;
    i++;
    cout <<"i=" <<i <<"a=" <<a;
    //输出结果为：i=6 a=2  i=6 a=3
}
```



### 动态生存期

当函数（局部作用域）中的变量采用static修饰时，该变量不会在每次调用后被销毁，也就是下一次调用该函数时依旧保存上一次调用的状态，同时该变量也不会在每次调用都被初始化

## 静态成员

### 静态数据成员

静态数据成员在**类内声明，在类外定义**，与类的其他成员函数一样，可以是public、private或protected。静态数据成员是属于类的，不是属于对象的，也就是说，无论创建多少个对象，静态数据成员只有一个副本，**被所有的对象共享**。静态数据成员的初始化必须在类外进行。

```c++
#include <iostream>
using namespace std;
class Person
{
public:
    static int age;
    Person()
    {
        count++;
    }
    static void getCount()
    {
        cout<<"Person count:"<<count<<endl;
    }
private:
    static int count;
};
//静态数据成员可以被所有的对象共享，因此静态数据成员的值可以被所有的对象访问和修改。同时，静态数据成员也可以被类的成员函数访问和修改。
int Person::age = 0;
int Person::count = 0;
//需要注意的是，在类中声明静态数据成员只是声明，而不是定义。因此，在类外必须对静态数据成员进行定义，并且不需要使用static关键字。
int main()
{
    cout<<Person::age<<endl;
    Person p1;
    Person::getCount();
    Person p2;
    Person::getCount();
    //getCount函数就是一个静态成员函数，它可以访问静态成员变量count。静态成员函数没有this指针，因此不能访问非静态成员。需要使用类名和作用域解析符号::来访问静态数据成员和静态成员函数。
    return 0;
}
//age是Person类的静态数据成员，count是Person类的静态成员变量，它们都被初始化为0。由于age是静态数据成员，所以可以使用Person::age来访问它。在main函数中，先输出了age的值，然后创建了两个Person对象，每创建一个对象，count就加1，最后调用了getCount函数来输出对象的数量。
```

### 静态函数成员

- 静态函数成员是属于类的，而不是属于对象的函数成员。静态函数成员可以通过**类名**和作用域解析符号::来调用，**不需要创建类的对象。**
- 静态函数成员，可以直接访问静态成员变量和静态成员函数。而访问非静态成员，必须通过对象名。
- 静态函数成员通常用来处理和类有关的任务，而不是对象的任务

```c++
#include <iostream>
using namespace std;
class Person{
public:
    static int age;
    Person(){
        count++;
    }
    static void getCount(){
        cout<<"Person count:"<<count<<endl;
    }
private:
    static int count;
};
int Person::age = 0;
int Person::count = 0;
int main(){
    Person::getCount();
    Person p1;
    Person::getCount();
    Person p2;
    Person::getCount();
    return 0;
}
```

需要注意的是，静态函数成员不能被声明为`const、volatile和virtual`，因为静态函数成员没有`this`指针，而`const、volatile和virtual`都需要`this`指针。另外，静态函数成员也不能被声明为`friend`，因为`friend`关键字只能用于非静态成员函数。

## 类的友元

友元关系提供了不同类或对象的成员函数之间、类的成员函数之间与一般函数之间进行数据共享的机制

### 友元函数

- 友元函数可以是非成员函数，也可以是其他类的成员函数。
- 但可以访问类的私有成员。友元函数可以在类定义内部或外部进行声明，但**必须在类外部进行定义**。

```c++
#include <iostream>
using namespace std;
class Person
{
public:
    Person(int age)
    {
        this->age = age;
    }
    friend void getAge(Person p);//友元函数在声明时必须在函数名前加上关键字friend
private:
    int age;
};
void getAge(Person p)
{
    cout<<"Person age:"<<p.age<<endl;
}
int main()
{
    Person p(18);
    getAge(p);
    return 0;
}
```

### 友元类

- 实现类之间的数据共享。
- 若A类为B类的友元类，则A的所有成员函数都是B的友元函数，都可以访问B的私有和保护成员
- 友元关系是**单向的且不能传递**、不能继承

```C++
class A
{
    public:
    	void display()
        {
            cout << x << endl;
        }
    	int getX()
        {
            return x;
        }
    	friend class B;  // B是A的友元类
    //其他成员略
    private:
    	int x;
};
class B
{
    public:
    	void set(int i); 
        void display();
    private:
    	A a;
};
void B::set(int i)
{
    a.x = i;  // 由于B是A的友元，所以在B中可以访问A类对象的私有成员
}
```



## 常类型

### 常对象

1. 常对象必须进行初始化，而且不能被更新
2. 语法形式： `const 类型说明符 对象名`
3. 不能通过常对象调用普通的成员函数

```c++
class MyClass {
    // class definition
};

const MyClass obj; // 常对象
```



指针类型的常对象可以有两种声明方式：指针本身不是常量，但指向的对象是常量。这意味着指针可以被重新赋值，但不能用来修改指向的常量对象。

```c++
const int *ptr1;   // ptr1是指向常量整数的指针
int const *ptr2;   // ptr2是指向常量整数的指针，与ptr1等效
```

### 用`const`修饰的类成员

#### 类成员函数

`类型说明符 函数名（参数表）const ;`  /   `类型说明符 函数名（参数表）const {}`

1. `const`是函数类型的一个组成部分，函数的定义部分也应有`const`关键字
2. 通过一个常对象，只能常成员函数
3. 常成员函数不能更新目的对象的数据成员
4. `const`关键字可用于区分重载函数

```c++
//例如：
void print();
void print() const;
```

#### 常数据成员

构造函数时对该数据成员进行初始化，**<u>只能通过初始化列表</u>**

```c++
class MyClass {
public:
    MyClass(int x, int y) : const_member(x), nonconst_member(y) {}
private:
    const int const_member;     // 常数据成员
    int nonconst_member;        // 非常数据成员
};
```



```c++
class MyClass {
public:
    MyClass(int value) : const_member(value) {}
    int get_const_member() const { return const_member; } // 常成员函数
private:
    const int const_member; // const成员变量
};
```

#### 常引用

1. 非常引用只能绑定普通对象
2. 常引用能绑定普通对象，也能绑定常对象
3. 常引用**引用的对象**不能被更新
   `const 类型说明符 &引用名`

#### 常数组

`类型说明符 const 数组名[大小]`

## 多文件结构和编译预处理命令

### 编译预处理命令

C++编译预处理命令是在源代码被编译之前对源代码进行预处理的一组命令。

1. \#include：用于包含头文件。

   `#include <文件名>`：标准方式搜索   /   `#iinclude "文件名"`：首先在文件目录中搜索，若没有，再按照标准方式寻找
   例如：

```c++
#include <iostream>  // 这个命令会将iostream头文件包含到源代码中。
```

   2.\#define：用于定义宏。例如：

```3c++
#define PI 3.14159  //这个命令将宏PI定义为3.14159。
```

   3.`#undef`  删除先前定义的宏

   4.`#if / #else / #elif / #endif`：用于条件编译。例如：

```c++
#if defined(_WIN32)
    // Windows-specific code here
#elif defined(__linux__)
    // Linux-specific code here
#else
    // Other operating systems code here
#endif
```

这个命令根据不同的条件选择不同的代码块进行编译。

​     5.\#pragma：用于向编译器传递特定的指令。例如：

```c++
#pragma warning(disable : 4996)
```

这个命令用于禁用编译器对指定警告的显示。

这些预处理命令可以在源代码中灵活使用，帮助程序员进行代码的组织和调试，提高代码的可读性和可维护性。

### 多文件结构

通常，一个C++程序可以被拆分为多个文件，例如：

1. 头文件（.h或.hpp文件）：包含类的声明、常量、函数原型等。
2. 源文件（.cpp文件）：包含类的实现、函数的定义等。
3. 主函数文件（.cpp文件）：包含程序入口函数main的定义。

一个头文件可以被多个源文件包含，这样就可以实现**多个源文件共享同一个类或函数的定义**。在源文件中，需要使用#include命令将需要的头文件包含进来。例如，如果有一个头文件MyClass.h，包含了MyClass类的声明，那么在源文件中需要这样包含它：

```c++
#include "MyClass.h"
```

**注意，在包含头文件时使用双引号" "而不是尖括号< >，这样可以告诉编译器在当前目录下查找头文件。**

**当多个源文件中包含同一个头文件时，会导致头文件被多次包含。这种情况下，可以使用头文件保护宏（header guard）来防止重复包含**，例如：

```c++
#ifndef MYCLASS_H
#define MYCLASS_H
// header file contents here
#endif
```

这样，当第一个源文件包含MyClass.h时，MYCLASS_H会被定义，当第二个源文件再次包含MyClass.h时，MYCLASS_H已经被定义，就不会再次包含MyClass.h了。

# 数组、指针与字符串

## 指针

### 初始化

`存储类型 数据类型 * 指针名 = 初始地址` **一定是地址值**

```c++
int i = 0;
int * ptr = &i;
```





- 可以把0赋值给指针变量，表示空指针
- 指针的类型是它所指向的变量的类型
- 允许声明指向void类型的指针，它后续可以被赋予任何类型

### 指向常量的指针

不可通过指针来改变所指对象的值；但指针本身可变，可以指向其他的对象

```c++
const char * name = "john";
char s[] = "my";
*name = "my";  // wrong
name = s; //right
```

### 指针常量

指针本身的值不可被改变，但是可以改变其所指向的值

```c++
```

### 指向数组元素的指针

```c++
int a[10];
int * pa = NULL;
pa = a; // 或 pa = &a[0]
//a[i] / *(pa+i) / *(a+i) / pa[i]   均为等价
```

**不能写`a++` 因为a是数组首地址，是常量**

### 指针数组

```c++
int * ptr[10] //数组的元素是指针
```

### 对象指针

`类名 * 对象指针名 `

访问成员：`对象指针名 -> 成员名`

### this指针





























# 注意事项

1. 只有构造函数可以使用初始化列表进行初始化





